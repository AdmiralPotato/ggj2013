<!DOCTYPE html>
<html>
<head>
<title>Global Game Jam 2013</title>
<style>
	*{
		margin: 0;
		padding: 0;
		border: 0;
		outline: 0;
	}
	canvas{
		position: fixed;
		top: 0;
		left: 0;
	}
</style>
</head>
<body>
<script type = "text/javascript" src = "https://raw.github.com/mrdoob/three.js/master/build/three.js">
</script>
<script>

	window.requestAnimFrame = (function(){
		return  window.requestAnimationFrame       ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame    ||
			window.oRequestAnimationFrame      ||
			window.msRequestAnimationFrame     ||
			function( callback ){
				window.setTimeout(callback, 1000 / 60);
			};
	})();

	var width = window.innerWidth;
	var height = window.innerHeight;

	var scene = new THREE.Scene();
	var camera = new THREE.PerspectiveCamera(50, width/height, 0.1, 1000);
	scene.add(camera);
	//var rend = new THREE.WebGLRenderer();
	rend = new THREE.WebGLRenderer( { clearColor: 0x020202, clearAlpha: 1, antialias: true } );
	rend.setSize(width, height);
	document.body.appendChild(rend.domElement);

	var geometryObjects = {};
	var parseAllGeometry = function(_geoPath, _callback) {
		var propertyName, modelData, modelCount = 0, modelsLoaded = 0;

		for(propertyName in _geoPath){
			if(_geoPath.hasOwnProperty(propertyName)){

				modelCount += 1;
				modelData = _geoPath[propertyName];


				function createMesh(_propertyName){
					var meshCreationHandler = function(_geometry, _materials) {
						_geometry.computeTangents();
						_geometry.matLib = _materials;
						geometryObjects[_propertyName] = _geometry;

						modelsLoaded += 1;

						if(modelsLoaded === modelCount){
							_callback();
						}
					};
					var jsonLoader = new THREE.JSONLoader();
					jsonLoader.load(modelData, meshCreationHandler);
				}
				createMesh(propertyName);
			}
		}
	}
	var fishShipMesh;
	var whatToDoWhenAllTheGeometriesAreParsedOkayYupSeriously = function(){
		fishShipMesh = new THREE.Mesh(geometryObjects.fishShip, geometryObjects.fishShip.matLib[0]);
		scene.add(fishShipMesh);

		var spearMesh = new THREE.Mesh(geometryObjects.spear, geometryObjects.spear.matLib[0]);
		spearMesh.position.z = -20;
		scene.add(spearMesh);

		var starbaseMesh = new THREE.Mesh(geometryObjects.starbase, geometryObjects.starbase.matLib[0]);
		starbaseMesh.position.x = -50;
		scene.add(starbaseMesh);


		var directionalLightA = new THREE.DirectionalLight(0xffffff,2);
		directionalLightA.position.set( 0, -1, 0 );
		fishShipMesh.add(directionalLightA);

		var directionalLightB = new THREE.DirectionalLight(0xffffff,1.5);
		directionalLightB.position.set( 0, 1, 0 );
		fishShipMesh.add(directionalLightB);

		var directionalLightPointedFromCamera = new THREE.DirectionalLight(0xffffff, 0.5);
		directionalLightPointedFromCamera.position.set( -1, 0, 0 );
		camera.add(directionalLightPointedFromCamera);
		update();
	};


	parseAllGeometry(
		{
			'fishShip': "../models/FishShip.json",
			'spear': "../models/Spear.json",
			'starbase': "../models/Starbase.json"
		},
		whatToDoWhenAllTheGeometriesAreParsedOkayYupSeriously
	);
	var tau = Math.PI*2;
	var deg = tau/360;

	var paused = false;

	var last = Date.now()/1000;

	var update = function(){
		requestAnimFrame(update);
		var now = Date.now()/1000; // get current time
		var dt = ((now-last) > .2) ? .2 : now-last; // calculate time between frames
		last = now; // save new time
		if(paused == false){ // main 'update' loop
			// use dt for frame rate independent speed
			fishShipMesh.rotation.setY(fishShipMesh.rotation.y+(dt*.1));
			camera.position = distanceElevationHeading(30, 15 * deg, fishShipMesh.rotation.y);
			camera.lookAt(fishShipMesh.position);

		}
		render();
	}

	var render = function(){
		
		if(window.innerWidth != width || window.innerHeight != height){
			width = window.innerWidth;
			height = window.innerHeight;
			camera.aspect = width/height;
			camera.updateProjectionMatrix();
			rend.setSize(width, height);
		}
		rend.render(scene, camera);
	};

	var distanceElevationHeading = function (_distance, _elevation, _heading){
		var radH = _heading + Math.PI;
		var radE = _elevation;
		var a = _distance * Math.cos(radE);
		return new THREE.Vector3(a * Math.cos(radH), _distance * Math.sin(radE), -a * Math.sin(radH));
	};

// create the particle variables
var particleCount = 1800,
    particles = new THREE.Geometry(),
 	pMaterial = new THREE.ParticleBasicMaterial({
    	color: 0xFFFFFF,
    	size: 20,
		map: THREE.ImageUtils.loadTexture(
      	"particle.png"
    ),
    blending: THREE.AdditiveBlending,
    transparent: true
  });

// now create the individual particles
for(var p = 0; p < particleCount; p++) {

  // create a particle with random
  // position values, -250 -> 250
  var pX = Math.random() * 500 - 250,
      pY = Math.random() * 500 - 250,
      pZ = Math.random() * 500 - 250,
      particle = new THREE.Vertex(
        new THREE.Vector3(pX, pY, pZ)
      );

  // add it to the geometry
  particles.vertices.push(particle);
}

// create the particle system
var particleSystem =
  new THREE.ParticleSystem(
    particles,
    pMaterial);
particleSystem.sortParticles = true;
// add it to the scene
scene.add(particleSystem);


/*
// create the particle variables
var pMaterial =
  new THREE.ParticleBasicMaterial({
    color: 0xFFFFFF,
    size: 20,
    map: THREE.ImageUtils.loadTexture(
      "images/particle.png"
    ),
    blending: THREE.AdditiveBlending,
    transparent: true
  });

// also update the particle system to
// sort the particles which enables
// the behaviour we want
particleSystem.sortParticles = true;
*/
</script>
</body>