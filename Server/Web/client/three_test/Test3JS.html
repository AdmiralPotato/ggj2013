<!DOCTYPE html>
<html>
<head>
<title>Global Game Jam 2013</title>
<style>
	*{
		margin: 0;
		padding: 0;
		border: 0;
		outline: 0;
	}
	canvas{
		position: fixed;
		top: 0;
		left: 0;
	}
</style>
</head>
<body>
<script type = "text/javascript" src = "https://raw.github.com/mrdoob/three.js/master/build/three.js">
</script>
<script>

	window.requestAnimFrame = (function(){
		return  window.requestAnimationFrame       ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame    ||
			window.oRequestAnimationFrame      ||
			window.msRequestAnimationFrame     ||
			function( callback ){
				window.setTimeout(callback, 1000 / 60);
			};
	})();

	var width = window.innerWidth;
	var height = window.innerHeight;

	var scene = new THREE.Scene();
	var camera = new THREE.PerspectiveCamera(50, width/height, 0.1, 10000);
	scene.add(camera);
	//var rend = new THREE.WebGLRenderer();
	rend = new THREE.WebGLRenderer( { /*clearColor: 0x1F94C2, clearAlpha: 1, */antialias: true } );
	rend.autoClear = false;
	rend.setSize(width, height);
	document.body.appendChild(rend.domElement);

	var geometryObjects = {};
	var parseAllGeometry = function(_geoPath, _callback) {
		var propertyName, modelData, modelCount = 0, modelsLoaded = 0;

		for(propertyName in _geoPath){
			if(_geoPath.hasOwnProperty(propertyName)){

				modelCount += 1;
				modelData = _geoPath[propertyName];


				function createMesh(_propertyName){
					var meshCreationHandler = function(_geometry, _materials) {
						_geometry.computeTangents();
						_geometry.matLib = _materials;
						geometryObjects[_propertyName] = _geometry;

						modelsLoaded += 1;

						if(modelsLoaded === modelCount){
							_callback();
						}
					};
					var jsonLoader = new THREE.JSONLoader();
					jsonLoader.load(modelData, meshCreationHandler);
				}
				createMesh(propertyName);
			}
		}
	}
	var keys = {};

	var keyHandlers = {
		"32down": function(){
			paused = !paused;
		}
	};
	var onKeyDown=function(e){
		e=(e||window.event);
		//if(e.preventDefault){e.preventDefault();}
		var kc = /*String.fromCharCode(*/(e.keyCode||e.which)/*)*/;
		if(null == keys[kc]){
			keys[kc] = true;
			if(keyHandlers[kc+"down"]){
				keyHandlers[kc+"down"]();
			}
		}
	}
	var onKeyUp=function(e){
		e=(e||window.event);
		//if(e.preventDefault){e.preventDefault();}
		var kc = /*String.fromCharCode(*/(e.keyCode||e.which)/*)*/;
		if(true == keys[kc]){
			delete keys[kc];
			if(keyHandlers[kc+"up"]){
				keyHandlers[kc+"up"]();
			}
		}
	}
	var enemies = [];
	var weapons = [];
	var player;
	var starBox1;
	var starBox2;
	var starBox3;
	var whatToDoWhenAllTheGeometriesAreParsedOkayYupSeriously = function(){
		document.addEventListener("keydown", onKeyDown, false);
		document.addEventListener("keyup", onKeyUp, false);

		// urls of the images,
		// one per half axis
		var urls = [
			'../models/starfield.png',
			'../models/starfield.png',
			'../models/starfield.png',
			'../models/starfield.png',
			'../models/starfield.png',
			'../models/starfield.png'
    	];

    	// wrap it up into the
   	 	// object that we need
    	var cubemap = THREE.ImageUtils.loadTextureCube(urls);

		// set the format, likely RGB
		// unless you've gone crazy
		cubemap.format = THREE.RGBFormat;

		var shader = THREE.ShaderLib["cube"];
		shader.uniforms["tCube"].value = cubemap;

		var material = new THREE.ShaderMaterial( {
 
          fragmentShader: shader.fragmentShader,
          vertexShader: shader.vertexShader,
          uniforms: shader.uniforms,
          depthWrite: false,
 			side:THREE.BackSide
        });

		var newMesh = new THREE.Mesh(new THREE.CubeGeometry(500, 500, 500, 5, 5, 5),
			material);

		newMesh.flipSided = true;


		scene.add(newMesh);


		newMesh = new THREE.Mesh(geometryObjects.spear, geometryObjects.spear.matLib[0]);
		player = newMesh;
		scene.add(newMesh);

		

		newMesh = new THREE.Mesh(geometryObjects.fishShip, geometryObjects.fishShip.matLib[0]);
		enemies.push(newMesh);
		newMesh.position.z = -50;
		newMesh.position.x = -10;
		scene.add(newMesh);

		newMesh = new THREE.Mesh(geometryObjects.fishShip, geometryObjects.fishShip.matLib[0]);
		enemies.push(newMesh);
		newMesh.position.z = 10;
		newMesh.position.x = -90;
		scene.add(newMesh);

		newMesh = new THREE.Mesh(geometryObjects.fishShip, geometryObjects.fishShip.matLib[0]);
		enemies.push(newMesh);
		newMesh.position.z = -10;
		newMesh.position.x = 10;
		scene.add(newMesh);

		newMesh = new THREE.Mesh(geometryObjects.fishShip, geometryObjects.fishShip.matLib[0]);
		enemies.push(newMesh);
		newMesh.position.z = 5;
		newMesh.position.x = 190;
		scene.add(newMesh);

		

		/*newMesh = new THREE.Mesh(geometryObjects.starbase, geometryObjects.starbase.matLib[0]);
		newMesh.position.x = -70;
		newMesh.position.z = 10;
		enemies.push(newMesh);
		scene.add(newMesh);

		newMesh = new THREE.Mesh(geometryObjects.starbase, geometryObjects.starbase.matLib[0]);
		newMesh.position.x = 70;
		newMesh.position.z = -30;
		enemies.push(newMesh);
		scene.add(newMesh);*/

		var directionalLightA = new THREE.DirectionalLight(0xffffff,2);
		directionalLightA.position.set( 0, -1, 0 );
		player.add(directionalLightA);

		var directionalLightB = new THREE.DirectionalLight(0xffffff,1.5);
		directionalLightB.position.set( 0, 1, 0 );
		player.add(directionalLightB);

		var directionalLightPointedFromCamera = new THREE.DirectionalLight(0xffffff, 0.5);
		directionalLightPointedFromCamera.position.set( -1, 0, 0 );
		camera.add(directionalLightPointedFromCamera);
		update();
		makeLaser(player);
	};

	function makeLaser(_source, _target){
		_target = _target || enemies[/*Math.floor(Math.random() * enemies.length)*/3];

		var newLaser = new THREE.Mesh(
			geometryObjects.laser,
			geometryObjects.laser.matLib[0]);

		/** start laser update loop **/
		var distance = _source.position.distanceTo(_target.position);
		newLaser.scale.x = distance*0.5;
		newLaser.position = _source.position;

		var newRot = Math.atan2(_target.position.x - _source.position.x, 
			_target.position.z - _source.position.z);

		newLaser.rotation.setY(newRot-(90*deg));
		/** end laser update loop **/

		scene.add(newLaser);
		return newLaser;
	}

	var updateLaser = function(){

	}


	parseAllGeometry(
		{
			/*'starCube': "../models/StarCube.json",*/
			'laser': "../models/Laser.json",
			'fishShip': "../models/FishShip.json",
			'spear': "../models/Spear.json",
			'starbase': "../models/Starbase.json",
		},
		whatToDoWhenAllTheGeometriesAreParsedOkayYupSeriously
	);
	var tau = Math.PI*2;
	var deg = tau/360;

	var paused = false;

	var last = Date.now()/1000;
	var timer = 0.0;

	var updateObjects = [];

	var update = function(){
		requestAnimFrame(update);
		var now = Date.now()/1000; // get current time

		var dt = ((now-last) > .2) ? .2 : now-last; // calculate time between frames

		last = now; // save new time
		if(paused == false){ // main 'update' loop
			timer += dt;
		/****
		Add Update Stuff BELOW Here
		****/
			// use dt for frame rate independent speed
			player.rotation.setY(player.rotation.y+(dt*.1));
			camera.position = distanceElevationHeading(50, 15 * deg, player.rotation.y);
			camera.lookAt(player.position);

			var i = updateObjects.length;
			while(i--){
				updateObjects[i].update();
			}

			/*var pCount = particleCount;
  			while(pCount--) {

    			// get the particle
    			var particle =
      				particles.vertices[pCount];
      		console.log(pCount);
      		console.log(particles.vertices[pCount]);
	  
    			// check if we need to reset
    			if(particle.position.y < -200) {
      				particle.position.y = 200;
      				particle.velocity.y = 0;
    			}

    			// update the velocity with
    			// a splat of randomniz
    			particle.velocity.y -=
      				Math.random() * .1;

    			// and the position
    			particle.position.addSelf(
      			particle.velocity);
  			}

  			// flag to the particle system
  			// that we've changed its vertices.
  			particleSystem.
    		geometry.
    		__dirtyVertices = true;*/
		}

		/****
		Add Update Stuff ABOVE Here
		****/
		render();
	}

	var render = function(){
		
		if(window.innerWidth != width || window.innerHeight != height){
			width = window.innerWidth;
			height = window.innerHeight;
			camera.aspect = width/height;
			camera.updateProjectionMatrix();
			rend.setSize(width, height);
		}
		rend.render(scene, camera);
	};

	var distanceElevationHeading = function (_distance, _elevation, _heading){
		var radH = _heading + Math.PI;
		var radE = _elevation;
		var a = _distance * Math.cos(radE);
		return new THREE.Vector3(a * Math.cos(radH), _distance * Math.sin(radE), -a * Math.sin(radH));
	};
/*
// create the particle variables
var particleCount = 500,
    particles = new THREE.Geometry(),
 	pMaterial = new THREE.ParticleBasicMaterial({
    	color: 0xFFFFFF,
    	size: 20,
		map: THREE.ImageUtils.loadTexture(
      	"particle.png"
    ),
    blending: THREE.AdditiveBlending,
    transparent: true
  });

// now create the individual particles
for(var p = 0; p < particleCount; p++) {

  // create a particle with random
  // position values, -250 -> 250
  var pX = Math.random() * 500 - 250,
      pY = Math.random() * 500 - 250,
      pZ = Math.random() * 500 - 250,
      particle = new THREE.Vertex(
        new THREE.Vector3(pX, pY, pZ)
      );
      // create a velocity vector
	particle.velocity = new THREE.Vector3(
		0,              // x
		-Math.random(), // y: random vel
		0);
	// add it to the geometry
  	particles.vertices.push(particle);
}


// create the particle system
var particleSystem =
  new THREE.ParticleSystem(
    particles,
    pMaterial);
particleSystem.sortParticles = true;
// add it to the scene
scene.add(particleSystem);*/


</script>
</body>