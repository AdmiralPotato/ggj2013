<!DOCTYPE html>
<html>
<head>
<title>Global Game Jam 2013</title>
<style>
	*{
		margin: 0;
		padding: 0;
		border: 0;
		outline: 0;
	}
	canvas{
		position: fixed;
		top: 0;
		left: 0;
	}
</style>
</head>
<body>
<script type = "text/javascript" src = "https://raw.github.com/mrdoob/three.js/master/build/three.js">
</script>
<script>

	window.requestAnimFrame = (function(){
		return  window.requestAnimationFrame       ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame    ||
			window.oRequestAnimationFrame      ||
			window.msRequestAnimationFrame     ||
			function( callback ){
				window.setTimeout(callback, 1000 / 60);
			};
	})();

	var width = window.innerWidth;
	var height = window.innerHeight;

	var scene = new THREE.Scene();
	var camera = new THREE.PerspectiveCamera(50, width/height, 0.1, 1000);
	scene.add(camera);
	//var rend = new THREE.WebGLRenderer();
	rend = new THREE.WebGLRenderer( { clearColor: 0x020202, clearAlpha: 1, antialias: true } );
	rend.setSize(width, height);
	document.body.appendChild(rend.domElement);

	var geometryObjects = {};
	var parseAllGeometry = function(_geoPath, _callback) {
		var propertyName, modelData, modelCount = 0, modelsLoaded = 0;

		for(propertyName in _geoPath){
			if(_geoPath.hasOwnProperty(propertyName)){

				modelCount += 1;
				modelData = _geoPath[propertyName];


				function createMesh(_propertyName){
					var meshCreationHandler = function(_geometry, _materials) {
						_geometry.computeTangents();
						_geometry.matLib = _materials;
						geometryObjects[_propertyName] = _geometry;

						modelsLoaded += 1;

						console.log(_propertyName+":"+modelsLoaded+":"+modelCount);

						if(modelsLoaded === modelCount){
							_callback();
						}
					};
					var jsonLoader = new THREE.JSONLoader();
					jsonLoader.load(modelData, meshCreationHandler);
				}
				createMesh(propertyName);
			}
		}
	}
	var fishShipMesh;
	var whatToDoWhenAllTheGeometriesAreParsedOkayYupSeriously = function(){
		fishShipMesh = new THREE.Mesh(geometryObjects.fishShip, geometryObjects.fishShip.matLib[0]);
		scene.add(fishShipMesh);

		var spearMesh = new THREE.Mesh(geometryObjects.spear, geometryObjects.spear.matLib[0]);
		spearMesh.position.z = -20;
		scene.add(spearMesh);

		var starbaseMesh = new THREE.Mesh(geometryObjects.starbase, geometryObjects.starbase.matLib[0]);
		starbaseMesh.position.x = -50;
		scene.add(starbaseMesh);


		var directionalLightA = new THREE.DirectionalLight(0xffffff,2);
		directionalLightA.position.set( 0, -1, 0 );
		fishShipMesh.add(directionalLightA);

		var directionalLightB = new THREE.DirectionalLight(0xffffff,1.5);
		directionalLightB.position.set( 0, 1, 0 );
		fishShipMesh.add(directionalLightB);

		var directionalLightPointedFromCamera = new THREE.DirectionalLight(0xffffff, 0.5);
		directionalLightPointedFromCamera.position.set( -1, 0, 0 );
		camera.add(directionalLightPointedFromCamera);
		render();
	};


	parseAllGeometry(
		{
			'fishShip': "../models/FishShip.json",
			'spear': "../models/Spear.json",
			'starbase': "../models/Starbase.json"
		},
		whatToDoWhenAllTheGeometriesAreParsedOkayYupSeriously
	);
	var tau = Math.PI*2;
	var deg = tau/360;
	var render = function(){
		requestAnimFrame(render);
		if(window.innerWidth != width || window.innerHeight != height){
			width = window.innerWidth;
			height = window.innerHeight;
			camera.aspect = width/height;
			camera.updateProjectionMatrix();
			rend.setSize(width, height);
		}

		fishShipMesh.rotation.setY(fishShipMesh.rotation.y+(deg*.125));
		camera.position = distanceElevationHeading(30, 15 * deg, fishShipMesh.rotation.y);

		camera.lookAt(new THREE.Vector3(0,0,0));

		rend.render(scene, camera);
	};
	var distanceElevationHeading = function (_distance, _elevation, _heading){
		var radH = _heading + Math.PI;
		var radE = _elevation;
		var a = _distance * Math.cos(radE);
		return new THREE.Vector3(a * Math.cos(radH), _distance * Math.sin(radE), -a * Math.sin(radH));
	};

/*
// common material parameters

var ambient = 0x050505, diffuse = 0x331100, specular = 0xffffff, shininess = 10, scale = 23;

// normal map shader

var shader = THREE.ShaderUtils.lib[ "normal" ];
var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

uniforms[ "enableAO" ].value = true;
uniforms[ "enableDiffuse" ].value = false;
uniforms[ "enableSpecular" ].value = false;
uniforms[ "enableReflection" ].value = true;

uniforms[ "tNormal" ].texture = THREE.ImageUtils.loadTexture( "normal.jpg" );
uniforms[ "tAO" ].texture = THREE.ImageUtils.loadTexture( "ao.jpg" );

uniforms[ "tDisplacement" ].texture = THREE.ImageUtils.loadTexture( "displacement.jpg" );
uniforms[ "uDisplacementBias" ].value = - 0.428408 * scale;
uniforms[ "uDisplacementScale" ].value = 2.436143 * scale;

uniforms[ "uDiffuseColor" ].value.setHex( diffuse );
uniforms[ "uSpecularColor" ].value.setHex( specular );
uniforms[ "uAmbientColor" ].value.setHex( ambient );

uniforms[ "uShininess" ].value = shininess;

uniforms[ "tCube" ].texture = reflectionCube;
uniforms[ "uReflectivity" ].value = 0.1;

uniforms[ "uDiffuseColor" ].value.convertGammaToLinear();
uniforms[ "uSpecularColor" ].value.convertGammaToLinear();
uniforms[ "uAmbientColor" ].value.convertGammaToLinear();


var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: false };
var displacementMaterial = new THREE.ShaderMaterial( parameters );
*/

</script>
</body>