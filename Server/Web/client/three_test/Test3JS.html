<!DOCTYPE html>
<html>
<head>
<title>Global Game Jam 2013</title>
<style>
	*{
		margin: 0;
		padding: 0;
		border: 0;
		outline: 0;
	}
	canvas{
		position: fixed;
		top: 0;
		left: 0;
	}
</style>
</head>
<body>
<script type = "text/javascript" src = "https://raw.github.com/mrdoob/three.js/master/build/three.js">
</script>
<script>

	window.requestAnimFrame = (function(){
		return  window.requestAnimationFrame       ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame    ||
			window.oRequestAnimationFrame      ||
			window.msRequestAnimationFrame     ||
			function( callback ){
				window.setTimeout(callback, 1000 / 60);
			};
	})();

	var width = window.innerWidth;
	var height = window.innerHeight;

	var scene = new THREE.Scene();
	var camera = new THREE.PerspectiveCamera(50, width/height, 0.1, 1000);
	scene.add(camera);
	//var rend = new THREE.WebGLRenderer();
	rend = new THREE.WebGLRenderer( { clearColor: 0x020202, clearAlpha: 1, antialias: true } );
	rend.setSize(width, height);
	document.body.appendChild(rend.domElement);

	var geometryObjects = {};
	var parseAllGeometry = function(_geoPath, _callback) {
		var propertyName, modelData, modelCount = 0, modelsLoaded = 0;

		for(propertyName in _geoPath){
			if(_geoPath.hasOwnProperty(propertyName)){

				modelCount += 1;
				modelData = _geoPath[propertyName];


				function createMesh(_propertyName){
					var meshCreationHandler = function(_geometry, _materials) {
						_geometry.computeTangents();
						_geometry.matLib = _materials;
						geometryObjects[_propertyName] = _geometry;

						modelsLoaded += 1;

						if(modelsLoaded === modelCount){
							_callback();
						}
					};
					var jsonLoader = new THREE.JSONLoader();
					jsonLoader.load(modelData, meshCreationHandler);
				}
				createMesh(propertyName);
			}
		}
	}
	var keys = {};

	var keyHandlers = {
		"32down": function(){
			paused = !paused;
		}
	};
	var onKeyDown=function(e){
		e=(e||window.event);
		//if(e.preventDefault){e.preventDefault();}
		var kc = /*String.fromCharCode(*/(e.keyCode||e.which)/*)*/;
		if(null == keys[kc]){
			keys[kc] = true;
			if(keyHandlers[kc+"down"]){
				keyHandlers[kc+"down"]();
			}
		}
	}
	var onKeyUp=function(e){
		e=(e||window.event);
		//if(e.preventDefault){e.preventDefault();}
		var kc = /*String.fromCharCode(*/(e.keyCode||e.which)/*)*/;
		if(true == keys[kc]){
			delete keys[kc];
			if(keyHandlers[kc+"up"]){
				keyHandlers[kc+"up"]();
			}
		}
	}

	var meshObjects = {};

	var whatToDoWhenAllTheGeometriesAreParsedOkayYupSeriously = function(){
		document.addEventListener("keydown", onKeyDown, false);
		document.addEventListener("keyup", onKeyUp, false);


		var newMesh = new THREE.Mesh(geometryObjects.fishShip, geometryObjects.fishShip.matLib[0]);
		meshObjects['fish'] = newMesh;
		scene.add(newMesh);

		newMesh = new THREE.Mesh(geometryObjects.spear, geometryObjects.spear.matLib[0]);
		newMesh.position.z = -20;
		meshObjects['spear'] = newMesh;
		scene.add(newMesh);

		newMesh = new THREE.Mesh(geometryObjects.starbase, geometryObjects.starbase.matLib[0]);
		newMesh.position.x = -50;
		meshObjects['starbase'] = newMesh;
		scene.add(newMesh);


		var directionalLightA = new THREE.DirectionalLight(0xffffff,2);
		directionalLightA.position.set( 0, -1, 0 );
		meshObjects['fish'].add(directionalLightA);

		var directionalLightB = new THREE.DirectionalLight(0xffffff,1.5);
		directionalLightB.position.set( 0, 1, 0 );
		meshObjects['fish'].add(directionalLightB);

		var directionalLightPointedFromCamera = new THREE.DirectionalLight(0xffffff, 0.5);
		directionalLightPointedFromCamera.position.set( -1, 0, 0 );
		camera.add(directionalLightPointedFromCamera);
		update();
	};

	var fireLaser = function(){

	}

	parseAllGeometry(
		{
			'fishShip': "../models/FishShip.json",
			'spear': "../models/Spear.json",
			'starbase': "../models/Starbase.json"
		},
		whatToDoWhenAllTheGeometriesAreParsedOkayYupSeriously
	);
	var tau = Math.PI*2;
	var deg = tau/360;

	var paused = false;

	var last = Date.now()/1000;

	var update = function(){
		requestAnimFrame(update);
		var now = Date.now()/1000; // get current time
		var dt = ((now-last) > .2) ? .2 : now-last; // calculate time between frames
		last = now; // save new time
		if(paused == false){ // main 'update' loop
		/****
		Add Update Stuff BELOW Here
		****/
			// use dt for frame rate independent speed
			meshObjects['fish'].rotation.setY(meshObjects['fish'] .rotation.y+(dt*.1));
			camera.position = distanceElevationHeading(30, 15 * deg, meshObjects['fish'] .rotation.y);
			camera.lookAt(meshObjects['fish'] .position);
			
			/*var pCount = particleCount;
  			while(pCount--) {

    			// get the particle
    			var particle =
      				particles.vertices[pCount];
      		console.log(pCount);
      		console.log(particles.vertices[pCount]);
	  
    			// check if we need to reset
    			if(particle.position.y < -200) {
      				particle.position.y = 200;
      				particle.velocity.y = 0;
    			}

    			// update the velocity with
    			// a splat of randomniz
    			particle.velocity.y -=
      				Math.random() * .1;

    			// and the position
    			particle.position.addSelf(
      			particle.velocity);
  			}

  			// flag to the particle system
  			// that we've changed its vertices.
  			particleSystem.
    		geometry.
    		__dirtyVertices = true;*/
		}

		/****
		Add Update Stuff ABOVE Here
		****/
		render();
	}

	var render = function(){
		
		if(window.innerWidth != width || window.innerHeight != height){
			width = window.innerWidth;
			height = window.innerHeight;
			camera.aspect = width/height;
			camera.updateProjectionMatrix();
			rend.setSize(width, height);
		}
		rend.render(scene, camera);
	};

	var distanceElevationHeading = function (_distance, _elevation, _heading){
		var radH = _heading + Math.PI;
		var radE = _elevation;
		var a = _distance * Math.cos(radE);
		return new THREE.Vector3(a * Math.cos(radH), _distance * Math.sin(radE), -a * Math.sin(radH));
	};

// create the particle variables
var particleCount = 500,
    particles = new THREE.Geometry(),
 	pMaterial = new THREE.ParticleBasicMaterial({
    	color: 0xFFFFFF,
    	size: 20,
		map: THREE.ImageUtils.loadTexture(
      	"particle.png"
    ),
    blending: THREE.AdditiveBlending,
    transparent: true
  });

// now create the individual particles
for(var p = 0; p < particleCount; p++) {

  // create a particle with random
  // position values, -250 -> 250
  var pX = Math.random() * 500 - 250,
      pY = Math.random() * 500 - 250,
      pZ = Math.random() * 500 - 250,
      particle = new THREE.Vertex(
        new THREE.Vector3(pX, pY, pZ)
      );
      // create a velocity vector
	particle.velocity = new THREE.Vector3(
		0,              // x
		-Math.random(), // y: random vel
		0);
	// add it to the geometry
  	particles.vertices.push(particle);
}


// create the particle system
var particleSystem =
  new THREE.ParticleSystem(
    particles,
    pMaterial);
particleSystem.sortParticles = true;
// add it to the scene
scene.add(particleSystem);


</script>
</body>